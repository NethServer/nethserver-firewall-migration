#!/usr/bin/perl

#
# Copyright (C) 2022 Nethesis S.r.l.
# http://www.nethesis.it - nethserver@nethesis.it
#
# This script is part of NethServer.
#
# NethServer is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License,
# or any later version.
#
# NethServer is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with NethServer.  If not, see COPYING.
#

use strict;
use warnings;
use JSON;
use esmith::NetworksDB;
use NethServer::Firewall;

sub slurp {
    my $file = shift;
    my $data;
    open my $fh, '<', $file or die;
    local $/ = undef;
    $data = <$fh>;
    close $fh;

    # trim
    $data =~ s/^\s+|\s+$//g;

    return $data;
}

sub role2zone {
    my $role = shift;
    if ($role eq 'green') {
        return 'lan';
    } elsif ($role eq 'red') {
        return 'wan';
    }

    return $role;
}

my %counter = ('green' => 0, 'red' => '0', 'blue' => 0, 'orange' => 0);
sub role2interface {
    my $role = shift;
    my $ret = $role;
    $counter{$role} += 1;
    if ($role eq 'green') {
        $ret='lan';
    } elsif ($role eq 'red') {
        $ret='wan';
    }

    return $role.$counter{$role};
}

my $ndb = esmith::NetworksDB->open_ro();
my $fw = new NethServer::Firewall();

my %devices;
my @interfaces;
my %zones;
my @forwardings;
my @aliases;
my @vlans;
my @snats;
my @bridges;
my @bonds;

for my $i ($ndb->get_all_by_prop('type' => 'ethernet')) {
    my $addr_file = '/sys/class/net/'.$i->key.'/address';
    if (-e $addr_file) {
        $devices{$i->key} = slurp($addr_file);
    }
}

# Read hardware address of slaves from bonding
for my $i ($ndb->get_all_by_prop('type' => 'bond')) {
    my $bfile = '/proc/net/bonding/'.$i->key;
    if (-e $bfile) {
        my $slave = '';
        open my $fh, '<', $bfile or die;
        while( my $line = <$fh>)  {
            if ($line =~ /^Slave Interface: (.*)$/) {
                $slave = $1;
            } elsif ($line =~ /^Permanent HW addr: (.*)$/) {
                $devices{$slave} = $1
            }
        }
        close $fh;
    }
}

# Export ethernet, bridge and pppoe interfaces
for my $i ($ndb->interfaces()) {
    my %interface;
    if ($i->prop('type') =~ m/ethernet|bridge|vlan/ && $i->prop('role') =~ m/green|red|orange|blue/) {
        %interface = (
            'zone' => role2zone($i->prop('role')),
            'interface' => $i->prop('nslabel') ? $i->prop('nslabel') : role2interface($i->prop('role')),
            'ipaddr' => $i->prop('ipaddr') || '',
            'netmask' => $i->prop('netmask') || '',
            'proto' => $i->prop('bootproto') eq 'dhcp' ? 'dhcp' : 'static',
            'gateway' => $i->prop('gateway') ? $i->prop('gateway') : ''
        );
        if ($i->prop('type') eq 'ethernet') {
            $interface{'hwaddr'} = $devices{$i->key} || '';
        } elsif ($i->prop('type') eq 'bridge') {
            $interface{'device'} = $i->key;
        } elsif ($i->prop('type') eq 'vlan') {
            my ($device, $vid) = split(/\./, $i->key);
            $interface{'vid'} = $vid;
            $interface{'hwaddr'} = $devices{$device};
        }
    } elsif ($i->prop('type') eq 'xdsl' && $i->prop('role') eq 'red') {
        my @pppoe = $ndb->get_all_by_prop('role' => 'pppoe');
        next if not @pppoe;
        %interface = (
            'zone' => role2zone('red'),
            'interface' => $i->prop('provider') ? $i->prop('provider') : role2interface('red'),
            'username' => $i->prop('user') || '',
            'password' => $i->prop('Password') || '',
            'proto' => 'pppoe',
            'ipv6' => '0',
            'keepalive' => '100 5'
        );
        my $device = $pppoe[0];
        if ($device->prop('type') eq 'vlan') {
            my ($eth, $vid) = split(/\./, $device->key);
            $interface{'hwaddr'} = $devices{$eth};
            $interface{'vid'} = $vid;
        } else {
            $interface{'hwaddr'} = $devices{$device->key};
        }
    }
    if (%interface) {
        push(@interfaces, \%interface)
    }
}

# Export aliases
for my $a ($ndb->get_all_by_prop('type' => 'alias')) {
    my $device = $a->key;
    $device =~ s/:.*$//;
    my $parent = $ndb->get($device);
    next if !$parent;
    my $interface = '';
    my %alias = (
        'proto' => 'static',
        'ipaddr' => $a->prop('ipaddr'),
        'netmask' => $a->prop('netmask'),
        'gateway' => $a->prop('gateway') ? $a->prop('gateway') : ''
    );

    if ($parent->prop('type') eq 'ethernet') {
        my $hwaddr = $devices{$device};
        # search for network name
        for my $i (@interfaces) {
            if (defined($i->{'hwaddr'}) && $i->{'hwaddr'} eq $hwaddr) {
                $alias{'hwaddr'} = $i->{'interface'};
                last;
            }
        }
    } elsif ($parent->prop('type') =~ m/bridge|bond/) {
        $alias{'device'} = $device;
    } elsif ($parent->prop('type') eq 'vlan') {
        my ($eth, $vid) = split(/\./, $device);
        $alias{'hwaddr'} = $devices{$eth};
        $alias{'vid'} = $vid;
    } else {
        next;
    }
    push(@aliases, \%alias);

    # Retrieve source NAT, if present
    if ($a->prop('FwObjectNat')) {
        my ($type, $key) = split(/;/, $a->prop('FwObjectNat'));
        my $addr = $fw->getAddress($a->prop('FwObjectNat'));
        my %snat = (
            'name' => $key,
            'proto' => 'all',
            'src' => $interface,
            'src_ip' => $fw->getAddress($a->prop('FwObjectNat')),
            'target' => 'SNAT',
            'snat_ip' => $a->prop('ipaddr')
        );
        push(@snats, \%snat);
    }
}

# Export vlan devices
for my $v ($ndb->get_all_by_prop('type' => 'vlan')) {
    my ($device, $vid) = split(/\./, $v->key);
    my $hwaddr = $devices{$device};
    my %vlan = (
        'type' => '8021q',
        'hwaddr' => $devices{$device},
        'vid' => $vid
    );
    push(@vlans, \%vlan);
}

# Export bridge devices
for my $b ($ndb->get_all_by_prop('type' => 'bridge')) {
    my @ports;
    for my $i ($ndb->get_all_by_prop('role' => 'bridged')) {
        if ($i->prop('bridge') eq $b->key) {
            my $type = $i->prop('type');
            if ($type eq 'ethernet') {
                push(@ports, {'type'=> $type, 'hwaddr' => $devices{$i->key}});
            } elsif ($type eq 'vlan') {
                my ($eth, $vid) = split(/\./, $i->key);
                push(@ports, {'type'=> $type, 'hwaddr' => $devices{$eth}, 'vid' => $vid});
            }
        }
    }
    my %bridge = (
        'ports' => \@ports,
        'name' => $b->key
    );
    push(@bridges, \%bridge);
}

# Export bond interfaces
my @bond_map = ('balance-rr', 'active-backup', 'balance-xor', 'broadcast', '802.3ad', 'balance-tlb', 'balance-alb');
for my $b ($ndb->get_all_by_prop('type' => 'bond')) {
    my @slaves;
    for my $i ($ndb->get_all_by_prop('role' => 'slave')) {
         push(@slaves, $devices{$i->key});
    }
    my %bond = (
        'slaves' => \@slaves,
        'interface' => $b->key,
        'zone' => role2zone($b->prop('role')),
        'bonding_policy' => $bond_map[$b->prop('BondOptMode')],
        'ipaddr' => $b->prop('ipaddr') || '',
        'netmask' => $b->prop('netmask') || '',
        'proto' => $b->prop('bootproto') eq 'dhcp' ? 'dhcp' : 'static',
        'gateway' => $b->prop('gateway') ? $b->prop('gateway') : '',
        'name' => $b->key
    );
    push(@bonds, \%bond);
}

# Extract firewall zones from interfaces
for my $i ((@interfaces,@bonds)) {
    if (exists($zones{$i->{'zone'}})) {
        my $network = $zones{$i->{'zone'}}->{'network'};
        push(@$network, $i->{'interface'});
    } else {
        my @network = ($i->{'interface'});
        $zones{$i->{'zone'}} = {
            'name' => $i->{'zone'},
            'network' => \@network,
            'input' => $i->{'zone'} eq 'lan' ? 'ACCEPT' : 'REJECT',
            'forward' => $i->{'zone'} eq 'lan' ? 'ACCEPT' : 'REJECT',
            'output' => 'ACCEPT'
        };
    }
}

for my $z (keys(%zones)) {
    if ($z eq 'blue') {
        push(@forwardings, {'src' => $z, 'dest' => 'wan'});
        push(@forwardings, {'src' => 'lan', 'dest' => $z});
        if (exists($zones{'orange'})) {
            push(@forwardings, {'src' => $z, 'dest' => 'orange'});
        }
    } elsif ($z eq 'orange') {
        push(@forwardings, {'src' => $z, 'dest' => 'wan'});
        push(@forwardings, {'src' => 'lan', 'dest' => $z});
    }
}


my @ztmp = values(%zones);
print(encode_json({
            'interfaces' => \@interfaces,
            'zones' => \@ztmp,
            'forwardings' => \@forwardings,
            'aliases' => \@aliases,
            'vlans' => \@vlans,
            'snats' => \@snats,
            'bridges' => \@bridges,
            'bonds' => \@bonds
        }));
